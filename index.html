<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI çŒœæ•°å­—ç ´è§£å™¨ (Game Theory Solver)</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text-main: #1e293b;
            --text-sub: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        h1 {
            margin: 0;
            font-size: 1.8rem;
            color: var(--primary);
        }
        .subtitle {
            color: var(--text-sub);
            font-size: 0.9rem;
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 24px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
        }

        /* Status Bar */
        .status-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-sub);
            background: #f1f5f9;
            padding: 10px 15px;
            border-radius: 8px;
        }
        .highlight {
            color: var(--primary);
            font-family: monospace;
            font-size: 1.1em;
        }

        /* Main Interaction Area */
        .guess-display {
            text-align: center;
            margin: 20px 0;
        }
        .guess-number {
            font-family: 'Courier New', monospace;
            font-size: 3.5rem;
            font-weight: bold;
            letter-spacing: 8px;
            color: var(--text-main);
            background: #f8fafc;
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 10px 0;
            margin: 10px 0;
            transition: all 0.3s;
        }
        .guess-number.thinking {
            color: var(--text-sub);
            font-size: 1.5rem;
            letter-spacing: normal;
            border-color: transparent;
            animation: pulse 1.5s infinite;
        }

        /* Controls */
        .controls {
            text-align: center;
        }
        .btn-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        button {
            cursor: pointer;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s;
        }
        .btn-score {
            background-color: var(--bg);
            border: 2px solid var(--border);
            color: var(--text-main);
            min-width: 50px;
        }
        .btn-score:hover:not(:disabled) {
            border-color: var(--primary);
            color: var(--primary);
            background: #eff6ff;
        }
        .btn-reset {
            background-color: var(--text-sub);
            color: white;
            margin-top: 20px;
            width: 100%;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Progress Bar */
        .progress-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 99px;
            height: 6px;
            margin-top: 15px;
            overflow: hidden;
            display: none; /* Hidden by default */
        }
        .progress-bar {
            height: 100%;
            background-color: var(--primary);
            width: 0%;
            transition: width 0.1s;
        }
        .progress-text {
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-sub);
            margin-top: 5px;
            min-height: 1.2em;
        }

        /* History Table */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        th {
            color: var(--text-sub);
            font-weight: 600;
        }
        .col-step { width: 15%; }
        .col-guess { width: 30%; font-family: monospace; font-weight: bold; }
        .col-score { width: 20%; }
        .col-remain { width: 35%; text-align: right; }

        /* Animations */
        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .success-message {
            color: var(--success);
            font-weight: bold;
            text-align: center;
            font-size: 1.2rem;
            display: none;
        }
        .error-message {
            color: var(--danger);
            font-weight: bold;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>AI çŒœæ•°å­—ç ´è§£å™¨</h1>
        <div class="subtitle">åŸºäºåšå¼ˆè®ºä¸ä¿¡æ¯ç†µçš„æ™ºèƒ½ç ´è§£ (Python Logic Port)</div>
    </header>

    <div class="card">
        <div class="status-bar">
            <span>å½“å‰è½®æ¬¡: <span id="step-count" class="highlight">0</span></span>
            <span>å‰©ä½™å¯èƒ½æ€§: <span id="candidates-count" class="highlight">10000</span></span>
        </div>

        <div class="guess-display">
            <div style="color: var(--text-sub); font-size: 0.9rem;">AI å»ºè®®çŒœæµ‹</div>
            <div id="guess-output" class="guess-number">----</div>
            
            <div class="progress-container" id="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="progress-text" id="progress-text"></div>
        </div>

        <div class="controls" id="game-controls">
            <p style="margin-bottom: 10px;">è®¾å®šè€…åé¦ˆï¼šä½ç½®å’Œæ•°å€¼éƒ½å¯¹çš„æ•°é‡ (0-4)</p>
            <div class="btn-group">
                <button class="btn-score" onclick="handleFeedback(0)">0</button>
                <button class="btn-score" onclick="handleFeedback(1)">1</button>
                <button class="btn-score" onclick="handleFeedback(2)">2</button>
                <button class="btn-score" onclick="handleFeedback(3)">3</button>
                <button class="btn-score" onclick="handleFeedback(4)">4</button>
            </div>
        </div>

        <div id="result-message" class="success-message">ğŸ‰ ç ´è§£æˆåŠŸï¼</div>
        <div id="error-message" class="error-message">âš ï¸ å¼‚å¸¸ï¼šå‰©ä½™å¯èƒ½æ€§ä¸º0ï¼Œè¯·æ£€æŸ¥åé¦ˆæ˜¯å¦æ­£ç¡®ã€‚</div>

        <button class="btn-reset" onclick="initGame()">é‡ç½®æ¸¸æˆ</button>
    </div>

    <div class="card">
        <h3 style="margin-top: 0;">ç ´è§£è®°å½•</h3>
        <table>
            <thead>
                <tr>
                    <th class="col-step">è½®æ¬¡</th>
                    <th class="col-guess">çŒœæµ‹æ•°å­—</th>
                    <th class="col-score">åé¦ˆ</th>
                    <th class="col-remain">å‰©ä½™å«Œç–‘é¡¹</th>
                </tr>
            </thead>
            <tbody id="history-list">
                <!-- History items will go here -->
            </tbody>
        </table>
    </div>
</div>

<script>
    // ==========================================
    // Core Logic (Ported from Python)
    // ==========================================

    class GameTheorySolver {
        constructor() {
            this.allCombinations = [];
            // Generate 0000-9999
            for (let i = 0; i < 10000; i++) {
                this.allCombinations.push(String(i).padStart(4, '0'));
            }
            this.candidates = [...this.allCombinations];
            this.turn = 0;
            this.turn1Guess = "";
        }

        calculateScore(target, guess) {
            let score = 0;
            for (let i = 0; i < 4; i++) {
                if (target[i] === guess[i]) score++;
            }
            return score;
        }

        // Helper: Shuffle array
        shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Helper: Sample n elements
        sample(array, n) {
            const shuffled = this.shuffle([...array]);
            return shuffled.slice(0, n);
        }

        getBalancedOpening() {
            const boundaryPool = ['0', '1', '8', '9'];
            const middlePool = ['2', '3', '4', '5', '6', '7'];
            
            const p1 = this.sample(boundaryPool, 2);
            const p2 = this.sample(middlePool, 2);
            
            const selection = this.shuffle([...p1, ...p2]);
            return selection.join("");
        }

        getBalancedOpeningTurn2() {
            const boundaryPool = ['0', '1', '8', '9'];
            const middlePool = ['2', '3', '4', '5', '6', '7'];

            const digitsInS = new Set(this.turn1Guess.split(''));

            const newBoundary = boundaryPool.filter(d => !digitsInS.has(d));
            const newMiddle = middlePool.filter(d => !digitsInS.has(d));

            // Python logic samples 2 from remaining. 
            // Note: In theory if Turn 1 used too many from one pool, this might fail if <2 remain.
            // But with 2+2 split in Turn 1, there are always 2 left in Boundary and 4 in Middle.
            const p1 = this.sample(newBoundary, 2);
            const p2 = this.sample(newMiddle, 2);

            const selection = this.shuffle([...p1, ...p2]);
            return selection.join("");
        }

        // Async function to allow UI updates during heavy calculation
        async getBestGuess(progressCallback) {
            this.turn += 1;

            // Phase 1: Opening
            if (this.turn === 1) {
                this.turn1Guess = this.getBalancedOpening();
                return this.turn1Guess;
            }
            if (this.turn === 2) {
                return this.getBalancedOpeningTurn2();
            }

            // End Game shortcut
            if (this.candidates.length <= 2) {
                return this.candidates[0];
            }

            // Phase 2: Minimax
            let searchSpace;
            if (this.candidates.length > 500) {
                searchSpace = this.candidates; // Heuristic: only search candidates
            } else {
                searchSpace = this.allCombinations; // Global Minimax
            }

            let bestGuess = this.candidates[0];
            let minWorstCase = Infinity;

            const totalSearch = searchSpace.length;
            const checkStep = Math.max(1, Math.floor(totalSearch / 20)); // Update UI every 5%

            // Heavy loop with chunking
            for (let i = 0; i < totalSearch; i++) {
                const guess = searchSpace[i];

                // Yield to UI thread occasionally
                if (i % 200 === 0) {
                    if (progressCallback) progressCallback(i, totalSearch);
                    await new Promise(r => setTimeout(r, 0)); 
                }

                const scoreCounts = {};
                
                // Simulate against all current candidates
                for (const cand of this.candidates) {
                    const score = this.calculateScore(cand, guess);
                    scoreCounts[score] = (scoreCounts[score] || 0) + 1;
                }

                // Find worst case (max remaining candidates)
                let worstCase = 0;
                for (const s in scoreCounts) {
                    if (scoreCounts[s] > worstCase) worstCase = scoreCounts[s];
                }

                if (worstCase < minWorstCase) {
                    minWorstCase = worstCase;
                    bestGuess = guess;
                } else if (worstCase === minWorstCase) {
                    // Tie-breaker: prefer guesses that are possible answers
                    if (this.candidates.includes(guess)) {
                        bestGuess = guess;
                    }
                }

                // Pruning
                if (minWorstCase === 1) break;
            }

            return bestGuess;
        }

        updateCandidates(guess, realScore) {
            const before = this.candidates.length;
            this.candidates = this.candidates.filter(c => this.calculateScore(c, guess) === realScore);
            return this.candidates.length;
        }
    }

    // ==========================================
    // UI Logic
    // ==========================================

    let solver;
    let currentGuess = "";
    let isProcessing = false;

    // Elements
    const elGuessOutput = document.getElementById('guess-output');
    const elStepCount = document.getElementById('step-count');
    const elCandCount = document.getElementById('candidates-count');
    const elHistory = document.getElementById('history-list');
    const elProgressBar = document.getElementById('progress-bar');
    const elProgressContainer = document.getElementById('progress-container');
    const elProgressText = document.getElementById('progress-text');
    const elControls = document.getElementById('game-controls');
    const elResultMsg = document.getElementById('result-message');
    const elErrorMsg = document.getElementById('error-message');
    const btnScores = document.querySelectorAll('.btn-score');

    function initGame() {
        solver = new GameTheorySolver();
        currentGuess = "";
        isProcessing = false;
        
        // Reset UI
        elStepCount.innerText = "0";
        elCandCount.innerText = "10000";
        elHistory.innerHTML = "";
        elResultMsg.style.display = 'none';
        elErrorMsg.style.display = 'none';
        elControls.style.display = 'block';
        setButtonsDisabled(false);
        
        // Start first turn
        nextTurn();
    }

    function setButtonsDisabled(disabled) {
        btnScores.forEach(btn => btn.disabled = disabled);
    }

    async function nextTurn() {
        if (isProcessing) return;
        isProcessing = true;
        setButtonsDisabled(true);

        // UI: Thinking state
        elGuessOutput.innerText = "è®¡ç®—ä¸­...";
        elGuessOutput.classList.add('thinking');
        elProgressText.innerText = "";
        
        if (solver.candidates.length > 2 && solver.turn >= 2) {
             elProgressContainer.style.display = 'block';
        }

        // Small delay to allow UI to render "Thinking"
        await new Promise(r => setTimeout(r, 50));

        const startTime = performance.now();

        // Get suggestion from solver
        currentGuess = await solver.getBestGuess((current, total) => {
            // Update progress bar
            const pct = Math.floor((current / total) * 100);
            elProgressBar.style.width = pct + "%";
            elProgressText.innerText = `æ­£åœ¨æ¨æ¼”åšå¼ˆæ ‘: ${pct}%`;
        });

        const endTime = performance.now();
        const timeTaken = ((endTime - startTime) / 1000).toFixed(2);

        // Update UI with result
        elGuessOutput.classList.remove('thinking');
        elGuessOutput.innerText = currentGuess;
        elProgressContainer.style.display = 'none';
        elProgressText.innerText = `è€—æ—¶: ${timeTaken}s`;
        
        elStepCount.innerText = solver.turn;

        isProcessing = false;
        setButtonsDisabled(false);
    }

    function handleFeedback(score) {
        if (isProcessing) return;

        // Add to history
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${solver.turn}</td>
            <td style="font-family:monospace; font-weight:bold">${currentGuess}</td>
            <td><span style="background:#e2e8f0; padding:2px 6px; border-radius:4px;">${score}</span></td>
            <td style="text-align:right">${solver.candidates.length}</td>
        `;
        // Insert at top
        elHistory.insertBefore(row, elHistory.firstChild);

        if (score === 4) {
            gameWon();
            return;
        }

        // Update solver
        const remaining = solver.updateCandidates(currentGuess, score);
        elCandCount.innerText = remaining;

        // Update history last cell with new remaining count for better context? 
        // Actually, the history usually shows remaining *before* the guess or *after*?
        // Let's update the specific row to show remaining *after* filtering.
        row.cells[3].innerText = remaining;

        if (remaining === 0) {
            gameError();
        } else {
            nextTurn();
        }
    }

    function gameWon() {
        elResultMsg.style.display = 'block';
        elControls.style.display = 'none';
        elGuessOutput.style.borderColor = 'var(--success)';
        elGuessOutput.style.color = 'var(--success)';
    }

    function gameError() {
        elErrorMsg.style.display = 'block';
        elControls.style.display = 'none';
        elGuessOutput.style.borderColor = 'var(--danger)';
    }

    // Start on load
    initGame();

</script>

</body>
</html>
